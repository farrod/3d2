<!DOCTYPE html>
<html>
<head>
    <title>Enhanced 3D Model Viewer</title>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #file-input {
            margin-bottom: 10px;
        }
        #message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            display: none;
        }
        .control-group {
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .slider-container span {
            min-width: 40px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="controls-panel">
        <input type="file" id="file-input" accept=".glb,.gltf">
        <div class="control-group">
            <label>Background Color:</label>
            <input type="color" id="bg-color" value="#f0f0f0">
        </div>
        <div class="control-group">
            <label>Lighting Controls:</label>
            <div class="slider-container">
                <label>Ambient Light:</label>
                <input type="range" id="ambient-intensity" min="0" max="2" step="0.1" value="0.5">
                <span>0.5</span>
            </div>
            <div class="slider-container">
                <label>Direct Light:</label>
                <input type="range" id="direct-intensity" min="0" max="2" step="0.1" value="0.8">
                <span>0.8</span>
            </div>
            <div class="slider-container">
                <label>Exposure:</label>
                <input type="range" id="exposure" min="0" max="2" step="0.1" value="1">
                <span>1.0</span>
            </div>
        </div>
        <div class="control-group">
            <label>Object Position:</label>
            <div class="slider-container">
                <label>Left/Right:</label>
                <input type="range" id="position-x" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
            <div class="slider-container">
                <label>Up/Down:</label>
                <input type="range" id="position-y" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
            <div class="slider-container">
                <label>Forward/Back:</label>
                <input type="range" id="position-z" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
        </div>
        <div class="control-group">
            <label>Lens Effects:</label>
            <div class="slider-container">
                <label>Focal Length:</label>
                <input type="range" id="focal-length" min="10" max="200" step="1" value="50">
                <span>50mm</span>
            </div>
            <div class="slider-container">
                <label>Distortion:</label>
                <input type="range" id="barrel-distortion" min="-1" max="1" step="0.01" value="0">
                <span>0.00</span>
            </div>
        </div>
        <div class="control-group">
            <button id="reset-camera">Reset Camera</button>
            <button id="wireframe-toggle">Toggle Wireframe</button>
            <button id="reset-position">Reset Position</button>
        </div>
        <div id="message"></div>
        <div id="stats"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script>
        let scene, camera, renderer, controls, currentModel;
        let ambientLight, directionalLight;
        let composer, renderPass;
        const messageEl = document.getElementById('message');
        const statsEl = document.getElementById('stats');
        let isWireframe = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup with better initial position
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.maxDistance = 100;
            controls.minDistance = 1;

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Post-processing setup
            composer = new THREE.EffectComposer(renderer);
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Create and add lens distortion shader
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float distortion;
                uniform float focalLength;
                varying vec2 vUv;
                uniform sampler2D tDiffuse;

                vec2 distort(vec2 p) {
                    float d = length(p);
                    float z = sqrt(1.0 + d * d * distortion);
                    float r = (1.0 / focalLength) * atan(d * z) / d;
                    return p * r;
                }

                void main() {
                    vec2 p = (vUv * 2.0 - 1.0);
                    vec2 s = distort(p);
                    vec2 uv = (s + 1.0) * 0.5;
                    
                    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    } else {
                        gl_FragColor = texture2D(tDiffuse, uv);
                    }
                }
            `;

            const lensDistortionPass = new THREE.ShaderPass({
                uniforms: {
                    tDiffuse: { value: null },
                    distortion: { value: 0.0 },
                    focalLength: { value: 50.0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });
            lensDistortionPass.renderToScreen = true;
            composer.addPass(lensDistortionPass);

            setupEventListeners();
            animate();
        }

        function setupEventListeners() {
            // File input handler
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // Background color control
            document.getElementById('bg-color').addEventListener('input', function(e) {
                scene.background = new THREE.Color(e.target.value);
            });

            // Lighting controls
            document.getElementById('ambient-intensity').addEventListener('input', function(e) {
                ambientLight.intensity = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            document.getElementById('direct-intensity').addEventListener('input', function(e) {
                directionalLight.intensity = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            document.getElementById('exposure').addEventListener('input', function(e) {
                renderer.toneMappingExposure = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            // Position controls
            document.getElementById('position-x').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.x = -parseFloat(e.target.value);
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            document.getElementById('position-y').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.y = parseFloat(e.target.value);
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            document.getElementById('position-z').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.z = -parseFloat(e.target.value);
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            // Camera reset
            document.getElementById('reset-camera').addEventListener('click', function() {
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            // Wireframe toggle
            document.getElementById('wireframe-toggle').addEventListener('click', toggleWireframe);

            // Reset position button
            document.getElementById('reset-position').addEventListener('click', function() {
                if (currentModel) {
                    currentModel.position.set(0, 0, 0);
                    document.getElementById('position-x').value = 0;
                    document.getElementById('position-y').value = 0;
                    document.getElementById('position-z').value = 0;
                    document.getElementById('position-x').nextElementSibling.textContent = '0';
                    document.getElementById('position-y').nextElementSibling.textContent = '0';
                    document.getElementById('position-z').nextElementSibling.textContent = '0';
                }
            });

            // Lens distortion controls
            document.getElementById('focal-length').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                const lastPass = composer.passes[composer.passes.length - 1];
                lastPass.uniforms.focalLength.value = value;
                this.nextElementSibling.textContent = value + 'mm';
            });

            document.getElementById('barrel-distortion').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                const lastPass = composer.passes[composer.passes.length - 1];
                lastPass.uniforms.distortion.value = value;
                this.nextElementSibling.textContent = value.toFixed(2);
            });
            window.addEventListener('resize', onWindowResize);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            showMessage('Loading model...', 'blue');

            const loader = new THREE.GLTFLoader();
            const reader = new FileReader();

            reader.onload = function(e) {
                loader.parse(e.target.result, '', function(gltf) {
                    // Remove existing model
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    // Center and scale model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    currentModel.position.x = -center.x;
                    currentModel.position.y = -center.y;
                    currentModel.position.z = -center.z;

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    currentModel.scale.multiplyScalar(scale);

                    // Reset position sliders
                    document.getElementById('position-x').value = 0;
                    document.getElementById('position-y').value = 0;
                    document.getElementById('position-z').value = 0;
                    document.getElementById('position-x').nextElementSibling.textContent = '0';
                    document.getElementById('position-y').nextElementSibling.textContent = '0';
                    document.getElementById('position-z').nextElementSibling.textContent = '0';

                    // Update stats
                    updateModelStats(gltf);

                    showMessage('Model loaded successfully!', 'green');
                }, undefined, function(error) {
                    showMessage('Error loading model: ' + error.message, 'red');
                });
            };

            reader.readAsArrayBuffer(file);
        }

        function updateModelStats(gltf) {
            let vertexCount = 0;
            let triangleCount = 0;
            const materials = new Set();

            gltf.scene.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry;
                    vertexCount += geometry.attributes.position.count;
                    if (geometry.index) {
                        triangleCount += geometry.index.count / 3;
                    } else {
                        triangleCount += geometry.attributes.position.count / 3;
                    }
                    if (node.material) {
                        materials.add(node.material);
                    }
                }
            });

            statsEl.innerHTML = `
                <strong>Model Statistics:</strong><br>
                Vertices: ${vertexCount.toLocaleString()}<br>
                Triangles: ${Math.floor(triangleCount).toLocaleString()}<br>
                Materials: ${materials.size}
            `;
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            if (currentModel) {
                currentModel.traverse((node) => {
                    if (node.isMesh) {
                        node.material.wireframe = isWireframe;
                    }
                });
            }
        }

        function showMessage(text, color) {
            messageEl.style.display = 'block';
            messageEl.style.color = color;
            messageEl.style.background = color === 'red' ? '#ffe6e6' : 
                                       color === 'green' ? '#e6ffe6' : 
                                       '#e6f3ff';
            messageEl.textContent = text;
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
             
