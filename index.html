<!DOCTYPE html>
<html>
<head>
    <title>Enhanced 3D Model Viewer</title>
    <style>
        body { 
            margin: 0; 
            font-family: Arial, sans-serif;
        }
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #file-input {
            margin-bottom: 10px;
        }
        #message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            display: none;
        }
        .control-group {
            margin-top: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        .slider-container input[type="range"] {
            flex: 1;
        }
        .slider-container span {
            min-width: 40px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
        }
        button:hover {
            background: #45a049;
        }
        #loading-spinner {
            display: none;
            margin-left: 10px;
        }
        #stats {
            margin-top: 10px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="controls-panel">
        <input type="file" id="file-input" accept=".glb,.gltf">
        <div class="control-group">
            <label>Background Color:</label>
            <input type="color" id="bg-color" value="#f0f0f0">
        </div>
        <div class="control-group">
            <label>Lighting Controls:</label>
            <div class="slider-container">
                <label>Ambient Light:</label>
                <input type="range" id="ambient-intensity" min="0" max="2" step="0.1" value="0.5">
                <span>0.5</span>
            </div>
            <div class="slider-container">
                <label>Direct Light:</label>
                <input type="range" id="direct-intensity" min="0" max="2" step="0.1" value="0.8">
                <span>0.8</span>
            </div>
            <div class="slider-container">
                <label>Exposure:</label>
                <input type="range" id="exposure" min="0" max="2" step="0.1" value="1">
                <span>1.0</span>
            </div>
        </div>
        <div class="control-group">
            <label>Light Color:</label>
            <div class="slider-container">
                <label>Temperature:</label>
                <input type="range" id="light-temp" min="1000" max="10000" step="100" value="6500">
                <span>6500K</span>
            </div>
            <input type="color" id="light-color" value="#ffffff">
        </div>
        <div class="control-group">
            <label>Object Position:</label>
            <div class="slider-container">
                <label>Left/Right:</label>
                <input type="range" id="position-x" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
            <div class="slider-container">
                <label>Up/Down:</label>
                <input type="range" id="position-y" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
            <div class="slider-container">
                <label>Forward/Back:</label>
                <input type="range" id="position-z" min="-5" max="5" step="0.1" value="0">
                <span>0</span>
            </div>
        </div>
        <div class="control-group">
            <button id="reset-camera">Reset Camera</button>
            <button id="wireframe-toggle">Toggle Wireframe</button>
            <button id="reset-position">Reset Position</button>
        </div>
        <div class="control-group">
            <label>Lens Settings:</label>
            <div class="slider-container">
                <label>Focal Length:</label>
                <input type="range" id="focal-length" min="10" max="80" step="1" value="35">
                <span>35mm</span>
            </div>
            <div class="slider-container">
                <label>Distortion:</label>
                <input type="range" id="distortion" min="-1" max="1" step="0.01" value="0">
                <span>0</span>
            </div>
        </div>
        <div class="control-group">
            <label>Color Grading (LUT):</label>
            <input type="file" id="lut-input" accept=".cube,.3dl">
            <div class="slider-container">
                <label>LUT Intensity:</label>
                <input type="range" id="lut-intensity" min="0" max="100" step="1" value="100">
                <span>100%</span>
            </div>
            <button id="reset-lut">Reset Color Grading</button>
        </div>
        <div id="message"></div>
        <div id="loading-spinner">Loading...</div>
        <div id="stats"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LensDistortionShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LUTShader.js"></script>
    <script>
        let scene, camera, renderer, controls, currentModel;
        let composer, lensPass, lutPass;
        let currentLUTTexture = null;
        const messageEl = document.getElementById('message');
        const loadingSpinner = document.getElementById('loading-spinner');
        const statsEl = document.getElementById('stats');
        let isWireframe = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup with better initial position
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Renderer setup with better quality
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Enhanced controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.maxDistance = 100;
            controls.minDistance = 1;

            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Set up tone mapping
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            // Removed grid helper

            // Set up post processing
            composer = new THREE.EffectComposer(renderer);
            
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Lens distortion pass
            lensPass = new THREE.ShaderPass(THREE.LensDistortionShader);
            lensPass.uniforms.distortion.value = 0.0;
            lensPass.uniforms.focalLength.value = 35.0;
            composer.addPass(lensPass);
            
            // LUT pass
            lutPass = new THREE.ShaderPass(THREE.LUTShader);
            lutPass.uniforms.intensity.value = 1.0;
            composer.addPass(lutPass);

            setupEventListeners();
            animate();
        }

        // Convert color temperature to RGB
        function kelvinToRGB(temperature) {
            temperature = temperature / 100;
            let r, g, b;
            
            if (temperature <= 66) {
                r = 255;
                g = temperature;
                g = 99.4708025861 * Math.log(g) - 161.1195681661;
                
                if (temperature <= 19) {
                    b = 0;
                } else {
                    b = temperature - 10;
                    b = 138.5177312231 * Math.log(b) - 305.0447927307;
                }
            } else {
                r = temperature - 60;
                r = 329.698727446 * Math.pow(r, -0.1332047592);
                g = temperature - 60;
                g = 288.1221695283 * Math.pow(g, -0.0755148492);
                b = 255;
            }
            
            return {
                r: Math.min(255, Math.max(0, r)) / 255,
                g: Math.min(255, Math.max(0, g)) / 255,
                b: Math.min(255, Math.max(0, b)) / 255
            };
        }

        function setupEventListeners() {
            // File input handler
            document.getElementById('file-input').addEventListener('change', handleFileUpload);

            // Background color control
            document.getElementById('bg-color').addEventListener('input', function(e) {
                scene.background = new THREE.Color(e.target.value);
            });

            // Lighting controls
            document.getElementById('ambient-intensity').addEventListener('input', function(e) {
                ambientLight.intensity = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            document.getElementById('direct-intensity').addEventListener('input', function(e) {
                directionalLight.intensity = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            document.getElementById('exposure').addEventListener('input', function(e) {
                renderer.toneMappingExposure = parseFloat(e.target.value);
                this.nextElementSibling.textContent = e.target.value;
            });

            document.getElementById('light-temp').addEventListener('input', function(e) {
                const temp = parseInt(e.target.value);
                const rgb = kelvinToRGB(temp);
                const color = new THREE.Color(rgb.r, rgb.g, rgb.b);
                ambientLight.color.copy(color);
                directionalLight.color.copy(color);
                document.getElementById('light-color').value = '#' + color.getHexString();
                this.nextElementSibling.textContent = temp + 'K';
            });

            document.getElementById('light-color').addEventListener('input', function(e) {
                const color = new THREE.Color(e.target.value);
                ambientLight.color.copy(color);
                directionalLight.color.copy(color);
            });

            // Position controls
            document.getElementById('position-x').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.x = -parseFloat(e.target.value); // Inverted for intuitive left/right
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            document.getElementById('position-y').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.y = parseFloat(e.target.value);
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            document.getElementById('position-z').addEventListener('input', function(e) {
                if (currentModel) {
                    currentModel.position.z = -parseFloat(e.target.value); // Inverted for intuitive forward/back
                    this.nextElementSibling.textContent = e.target.value;
                }
            });

            // Reset position button
            document.getElementById('reset-position').addEventListener('click', function() {
                if (currentModel) {
                    currentModel.position.set(0, 0, 0);
                    document.getElementById('position-x').value = 0;
                    document.getElementById('position-y').value = 0;
                    document.getElementById('position-z').value = 0;
                    document.getElementById('position-x').nextElementSibling.textContent = '0';
                    document.getElementById('position-y').nextElementSibling.textContent = '0';
                    document.getElementById('position-z').nextElementSibling.textContent = '0';
                }
            });

            // Lens controls
            document.getElementById('focal-length').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                lensPass.uniforms.focalLength.value = value;
                this.nextElementSibling.textContent = value + 'mm';
            });

            document.getElementById('distortion').addEventListener('input', function(e) {
                const value = parseFloat(e.target.value);
                lensPass.uniforms.distortion.value = value;
                this.nextElementSibling.textContent = value.toFixed(2);
            });

            // LUT controls
            document.getElementById('lut-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    
                    // Parse LUT file (supporting .cube format)
                    if (file.name.endsWith('.cube')) {
                        const lutData = parseCubeLUT(content);
                        if (lutData) {
                            if (currentLUTTexture) {
                                currentLUTTexture.dispose();
                            }
                            currentLUTTexture = new THREE.DataTexture(
                                lutData,
                                32,
                                32,
                                THREE.RGBFormat,
                                THREE.FloatType
                            );
                            currentLUTTexture.needsUpdate = true;
                            lutPass.uniforms.lutMap.value = currentLUTTexture;
                            showMessage('LUT loaded successfully!', 'green');
                        }
                    } else {
                        showMessage('Unsupported LUT format. Please use .cube files.', 'red');
                    }
                };
                reader.readAsText(file);
            });

            document.getElementById('lut-intensity').addEventListener('input', function(e) {
                const value = parseInt(e.target.value) / 100;
                lutPass.uniforms.intensity.value = value;
                this.nextElementSibling.textContent = (value * 100).toFixed(0) + '%';
            });

            document.getElementById('reset-lut').addEventListener('click', function() {
                if (currentLUTTexture) {
                    currentLUTTexture.dispose();
                    currentLUTTexture = null;
                }
                lutPass.uniforms.lutMap.value = null;
                lutPass.uniforms.intensity.value = 1.0;
                document.getElementById('lut-intensity').value = 100;
                document.getElementById('lut-intensity').nextElementSibling.textContent = '100%';
                document.getElementById('lut-input').value = '';
                showMessage('Color grading reset', 'blue');
            });

            // Camera reset
            document.getElementById('reset-camera').addEventListener('click', function() {
                camera.position.set(5, 5, 5);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
            });

            // Wireframe toggle
            document.getElementById('wireframe-toggle').addEventListener('click', toggleWireframe);

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            loadingSpinner.style.display = 'inline';
            showMessage('Loading model...', 'blue');

            const loader = new THREE.GLTFLoader();
            const reader = new FileReader();

            reader.onload = function(e) {
                loader.parse(e.target.result, '', function(gltf) {
                    // Remove existing model
                    if (currentModel) {
                        scene.remove(currentModel);
                    }
                    
                    currentModel = gltf.scene;
                    scene.add(currentModel);

                    // Center and scale model
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    currentModel.position.x = -center.x;
                    currentModel.position.y = -center.y;
                    currentModel.position.z = -center.z;

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    currentModel.scale.multiplyScalar(scale);

                    // Update stats
                    updateModelStats(gltf);

                    loadingSpinner.style.display = 'none';
                    showMessage('Model loaded successfully!', 'green');
                }, undefined, function(error) {
                    loadingSpinner.style.display = 'none';
                    showMessage('Error loading model: ' + error.message, 'red');
                });
            };

            reader.readAsArrayBuffer(file);
        }

        function updateModelStats(gltf) {
            let vertexCount = 0;
            let triangleCount = 0;
            let materialCount = 0;
            const materials = new Set();

            gltf.scene.traverse((node) => {
                if (node.isMesh) {
                    const geometry = node.geometry;
                    vertexCount += geometry.attributes.position.count;
                    if (geometry.index) {
                        triangleCount += geometry.index.count / 3;
                    } else {
                        triangleCount += geometry.attributes.position.count / 3;
                    }
                    if (node.material) {
                        materials.add(node.material);
                    }
                }
            });

            statsEl.innerHTML = `
                <strong>Model Statistics:</strong><br>
                Vertices: ${vertexCount.toLocaleString()}<br>
                Triangles: ${Math.floor(triangleCount).toLocaleString()}<br>
                Materials: ${materials.size}
            `;
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            if (currentModel) {
                currentModel.traverse((node) => {
                    if (node.isMesh) {
                        node.material.wireframe = isWireframe;
                    }
                });
            }
        }

        function showMessage(text, color) {
            messageEl.style.display = 'block';
            messageEl.style.color = color;
            messageEl.style.background = color === 'red' ? '#ffe6e6' : 
                                       color === 'green' ? '#e6ffe6' : 
                                       '#e6f3ff';
            messageEl.textContent = text;
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function parseCubeLUT(content) {
            const lines = content.split('\n');
            const size = 32; // Standard size for LUT
            const data = new Float32Array(size * size * size * 3);
            
            let dataIndex = 0;
            for (const line of lines) {
                // Skip comments and empty lines
                if (line.startsWith('#') || line.trim() === '') continue;
                
                // Parse color values
                const values = line.trim().split(/\s+/).map(Number);
                if (values.length === 3) {
                    data[dataIndex++] = values[0];
                    data[dataIndex++] = values[1];
                    data[dataIndex++] = values[2];
                }
            }
            
            return data;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }

        init();
    </script>
</body>
</html>
